// 基本思路：遍历1~n每个元素i，i作为根节点，对1~(i-1)递归地建立左子树，对(i+1)~n递归建立右子树
// 结果只与序列元素个数有关，与序列无关。即1~n的结果和2~(n+1)的结果相同。因此用动态规划，而不是dfs
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];  // 用dp[i]表示i个元素的序列能有多少种二叉搜索树
        // 0个元素的序列是空树，1个元素的序列只有根
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; ++i){    // 计算dp数组
            // i个元素的序列，取1~i中的某个位置j，1~j的结果 × (j+1)~i的结果
            // (j+1)~i共有i-j个元素，(j+1)~i的结果等价于1~(i-j)的结果
            for(int j = 1; j <= i; ++j){
                dp[i] = dp[i] + dp[j-1] * dp[i-j];
            }
        }
        return dp[n];
    }
}
